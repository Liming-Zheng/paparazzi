/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 * File: compute_acc_cascaded_nonlinear_CA_w_ailerons_internal.c
 *
 * MATLAB Coder version            : 23.2
 * C/C++ source code generated on  : 21-Feb-2024 21:26:49
 */

/* Include Files */
#include "compute_acc_cascaded_nonlinear_CA_w_ailerons_internal.h"
#include "rt_nonfinite.h"
#include <math.h>
#include <string.h>

/* Function Definitions */
/*
 * Arguments    : const double u_in[15]
 *                double p
 *                double q
 *                double r
 *                double K_p_T
 *                double K_p_M
 *                double m
 *                double I_xx
 *                double I_yy
 *                double I_zz
 *                double l_1
 *                double l_2
 *                double l_3
 *                double l_4
 *                double l_z
 *                double Cl_alpha
 *                double Cd_zero
 *                double K_Cd
 *                double Cm_alpha
 *                double Cm_zero
 *                double CL_aileron
 *                double rho
 *                double V
 *                double S
 *                double wing_chord
 *                double flight_path_angle
 *                double Beta
 *                double accelerations_array[6]
 * Return Type  : void
 */
void c_compute_acc_cascaded_nonlinea(
    const double u_in[15], double p, double q, double r, double K_p_T,
    double K_p_M, double m, double I_xx, double I_yy, double I_zz, double l_1,
    double l_2, double l_3, double l_4, double l_z, double Cl_alpha,
    double Cd_zero, double K_Cd, double Cm_alpha, double Cm_zero,
    double CL_aileron, double rho, double V, double S, double wing_chord,
    double flight_path_angle, double Beta, double accelerations_array[6])
{
  double accelerations_array_tmp;
  double t10;
  double t11;
  double t12;
  double t13;
  double t14;
  double t15;
  double t16;
  double t17;
  double t18;
  double t19;
  double t20;
  double t21;
  double t22;
  double t23;
  double t25;
  double t26;
  double t27;
  double t28;
  double t29;
  double t3;
  double t31;
  double t32;
  double t33;
  double t34;
  double t35;
  double t36;
  double t37;
  double t38;
  double t4;
  double t40;
  double t41;
  double t42;
  double t42_tmp;
  double t43;
  double t43_tmp;
  double t44;
  double t45;
  double t46;
  double t47;
  double t49;
  double t5;
  double t53;
  double t54_tmp_tmp;
  double t56;
  double t57;
  double t58;
  double t6;
  double t7;
  double t8;
  double t9;
  /* COMPUTE_ACC_NONLINEAR_CONTROL_RF_W_AILERONS_V2 */
  /*     ACCELERATIONS_ARRAY =
   * COMPUTE_ACC_NONLINEAR_CONTROL_RF_W_AILERONS_V2(Beta,CL_aileron,Cd_zero,Cl_alpha,Cm_zero,Cm_alpha,I_xx,I_yy,I_zz,K_Cd,K_p_M,K_p_T,Omega_1,Omega_2,Omega_3,Omega_4,Phi,S,Theta,V,B_1,B_2,B_3,B_4,DELTA_AILERONS,FLIGHT_PATH_ANGLE,G_1,G_2,G_3,G_4,L_1,L_2,L_3,L_4,L_Z,M,P,Q,R,RHO,WING_CHORD)
   */
  /*     This function was generated by the Symbolic Math Toolbox version 9.3.
   */
  /*     20-Feb-2024 16:03:51 */
  t3 = cos(u_in[13]);
  t4 = sin(Beta);
  t5 = cos(u_in[12]);
  t6 = sin(u_in[13]);
  t7 = cos(u_in[4]);
  t8 = cos(u_in[5]);
  t9 = cos(u_in[6]);
  t10 = cos(u_in[7]);
  t11 = sin(u_in[12]);
  t12 = cos(u_in[8]);
  t13 = cos(u_in[9]);
  t14 = cos(u_in[10]);
  t15 = cos(u_in[11]);
  t16 = sin(u_in[4]);
  t17 = sin(u_in[5]);
  t18 = sin(u_in[6]);
  t19 = sin(u_in[7]);
  t20 = sin(u_in[8]);
  t21 = sin(u_in[9]);
  t22 = sin(u_in[10]);
  t23 = sin(u_in[11]);
  t25 = u_in[0] * u_in[0];
  t26 = u_in[1] * u_in[1];
  t27 = u_in[2] * u_in[2];
  t28 = u_in[3] * u_in[3];
  t29 = V * V;
  t31 = 1.0 / m;
  t32 = u_in[12] - flight_path_angle;
  t33 = K_p_T * t16 * t25;
  t34 = K_p_T * t17 * t26;
  t35 = K_p_T * t18 * t27;
  t36 = K_p_T * t19 * t28;
  t37 = K_p_T * t7;
  t40 = t37 * t12 * t25;
  t38 = K_p_T * t8;
  t41 = t38 * t13 * t26;
  t42_tmp = K_p_T * t9;
  t42 = t42_tmp * t14 * t27;
  t43_tmp = K_p_T * t10;
  t43 = t43_tmp * t15 * t28;
  t44 = t37 * t20 * t25;
  t45 = t38 * t21 * t26;
  t46 = t42_tmp * t22 * t27;
  t47 = t43_tmp * t23 * t28;
  t37 = cos(t32);
  t38 = sin(t32);
  t53 = ((t33 + t34) + t35) + t36;
  t56 = ((t40 + t41) + t42) + t43;
  t57 = ((t44 + t45) + t46) + t47;
  t42_tmp = Cl_alpha * S * rho * t29 * t32;
  t49 = Cd_zero + K_Cd * (Cl_alpha * Cl_alpha) * (t32 * t32);
  t54_tmp_tmp = S * rho;
  t43_tmp = t54_tmp_tmp * cos(Beta) * t29;
  t58 = t42_tmp * t37 / 2.0 + t43_tmp * t38 * t49 / 2.0;
  accelerations_array_tmp = t3 * t11;
  t42_tmp = t42_tmp * t38 / 2.0 - t43_tmp * t37 * t49 / 2.0;
  t43_tmp = t54_tmp_tmp * t4;
  accelerations_array[0] =
      -t31 * (((((t5 * t53 - t5 * t42_tmp) + accelerations_array_tmp * t56) +
                accelerations_array_tmp * t58) -
               t6 * t11 * t57) +
              t43_tmp * t6 * t11 * t29 * t49 / 2.0);
  accelerations_array[1] = t31 * (((t3 * t57 + t6 * t56) + t6 * t58) -
                                  t54_tmp_tmp * t3 * t4 * t29 * t49 / 2.0);
  accelerations_array_tmp = t3 * t5;
  accelerations_array[2] =
      -t31 * (((((-t11 * t53 + t11 * t42_tmp) + accelerations_array_tmp * t56) +
                accelerations_array_tmp * t58) -
               t5 * t6 * t57) +
              t43_tmp * t5 * t6 * t29 * t49 / 2.0) +
      9.81;
  accelerations_array[3] =
      ((((((((((((((l_1 * t40 - l_1 * t41) - l_2 * t42) + l_2 * t43) +
                 l_z * t44) +
                l_z * t45) +
               l_z * t46) +
              l_z * t47) +
             I_yy * q * r) -
            I_zz * q * r) +
           K_p_M * t16 * t25) -
          K_p_M * t17 * t26) +
         K_p_M * t18 * t27) -
        K_p_M * t19 * t28) +
       CL_aileron * S * u_in[14] * rho * t29 / 2.0) /
      I_xx;
  accelerations_array_tmp = I_xx * p;
  t42_tmp = K_p_M * t7;
  t43_tmp = K_p_M * t8;
  t38 = K_p_M * t9;
  t37 = K_p_M * t10;
  accelerations_array[4] =
      ((((((((((((((l_4 * t40 - l_3 * t42) + l_4 * t41) - l_3 * t43) +
                 l_z * t33) +
                l_z * t34) +
               l_z * t35) +
              l_z * t36) -
             accelerations_array_tmp * r) +
            I_zz * p * r) -
           t42_tmp * t20 * t25) +
          t43_tmp * t21 * t26) -
         t38 * t22 * t27) +
        t37 * t23 * t28) +
       t54_tmp_tmp * t29 * wing_chord * (Cm_zero + Cm_alpha * t32) / 2.0) /
      I_yy;
  accelerations_array[5] =
      -(((((((((((((l_1 * t33 - l_1 * t34) - l_2 * t35) + l_2 * t36) -
                 l_4 * t44) +
                l_3 * t46) -
               l_4 * t45) +
              l_3 * t47) -
             accelerations_array_tmp * q) +
            I_yy * p * q) -
           t42_tmp * t12 * t25) +
          t43_tmp * t13 * t26) -
         t38 * t14 * t27) +
        t37 * t15 * t28) /
      I_zz;
}

/*
 * File trailer for compute_acc_cascaded_nonlinear_CA_w_ailerons_internal.c
 *
 * [EOF]
 */
