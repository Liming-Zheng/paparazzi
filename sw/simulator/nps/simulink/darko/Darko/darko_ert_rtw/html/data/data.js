var dataJson = {"arch":{"ispc":false,"isunix":true,"ismac":false},"build":"darko","ref":false,"files":[{"name":"ert_main.c","type":"source","group":"main","path":"/home/florian/MATLAB-Drive/test_Embedded Coder/Darko/darko_ert_rtw","tag":"","groupDisplay":"Main file","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: ert_main.c\n *\n * Code generated for Simulink model 'darko'.\n *\n * Model version                  : 1.10\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\n * C/C++ source code generated on : Mon Dec 12 08:31:49 2022\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives:\n *    1. Execution efficiency\n *    2. RAM efficiency\n * Validation result: Not run\n */\n\n#include <stddef.h>\n#include <stdio.h>            /* This example main program uses printf/fflush */\n#include \"darko.h\"                     /* Model header file */\n\n/*\n * Associating rt_OneStep with a real-time clock or interrupt service routine\n * is what makes the generated code \"real-time\".  The function rt_OneStep is\n * always associated with the base rate of the model.  Subrates are managed\n * by the base rate from inside the generated code.  Enabling/disabling\n * interrupts and floating point context switches are target specific.  This\n * example code indicates where these should take place relative to executing\n * the generated code step function.  Overrun behavior should be tailored to\n * your application needs.  This example simply sets an error status in the\n * real-time model and returns from rt_OneStep.\n */\nvoid rt_OneStep(void);\nvoid rt_OneStep(void)\n{\n  static boolean_T OverrunFlag = false;\n\n  /* Disable interrupts here */\n\n  /* Check for overrun */\n  if (OverrunFlag) {\n    rtmSetErrorStatus(rtM, \"Overrun\");\n    return;\n  }\n\n  OverrunFlag = true;\n\n  /* Save FPU context here (if necessary) */\n  /* Re-enable timer or interrupt here */\n  /* Set model inputs here */\n\n  /* Step the model */\n  darko_step();\n\n  /* Get model outputs here */\n\n  /* Indicate task complete */\n  OverrunFlag = false;\n\n  /* Disable interrupts here */\n  /* Restore FPU context here (if necessary) */\n  /* Enable interrupts here */\n}\n\n/*\n * The example main function illustrates what is required by your\n * application code to initialize, execute, and terminate the generated code.\n * Attaching rt_OneStep to a real-time clock is target specific. This example\n * illustrates how you do this relative to initializing the model.\n */\nint_T main(int_T argc, const char *argv[])\n{\n  /* Unused arguments */\n  (void)(argc);\n  (void)(argv);\n\n  /* Initialize model */\n  darko_initialize();\n\n  /* Attach rt_OneStep to a timer or interrupt service routine with\n   * period 0.000977 seconds (base rate of the model) here.\n   * The call syntax for rt_OneStep is\n   *\n   *  rt_OneStep();\n   */\n  printf(\"Warning: The simulation will run forever. \"\n         \"Generated ERT main won't simulate model step behavior. \"\n         \"To change this behavior select the 'MAT-file logging' option.\\n\");\n  fflush((NULL));\n  while (rtmGetErrorStatus(rtM) == (NULL)) {\n    /*  Perform application tasks here */\n  }\n\n  return 0;\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"darko.c","type":"source","group":"model","path":"/home/florian/MATLAB-Drive/test_Embedded Coder/Darko/darko_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: darko.c\n *\n * Code generated for Simulink model 'darko'.\n *\n * Model version                  : 1.10\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\n * C/C++ source code generated on : Mon Dec 12 08:31:49 2022\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives:\n *    1. Execution efficiency\n *    2. RAM efficiency\n * Validation result: Not run\n */\n\n#include \"darko.h\"\n#include \"rtwtypes.h\"\n#include <emmintrin.h>\n#include <string.h>\n#include <math.h>\n#include <stddef.h>\n#define NumBitsPerChar                 8U\n\n/* Block signals and states (default storage) */\nDW rtDW;\n\n/* External inputs (root inport signals with default storage) */\nExtU rtU;\n\n/* External outputs (root outports fed by signals with default storage) */\nExtY rtY;\n\n/* Real-time model */\nstatic RT_MODEL rtM_;\nRT_MODEL *const rtM = &rtM_;\n\n/* Forward declaration for local functions */\nstatic real_T norm(const real_T x[4]);\nstatic real_T norm_j(const real_T x[3]);\nstatic void aero(const real_T x[13], const real_T T[3], real_T del, const real_T\n                 w[3], const real_T b_drone_PHI[36], real_T b_drone_RHO, real_T\n                 b_drone_WET_SURFACE, real_T b_drone_DRY_SURFACE, real_T\n                 b_drone_PHI_n, real_T b_drone_CHORD, real_T b_drone_WINGSPAN,\n                 real_T b_drone_PROP_RADIUS, const real_T\n                 b_drone_ELEVON_MEFFICIENCY[3], const real_T\n                 b_drone_ELEVON_FEFFICIENCY[3], real_T Fb[3], real_T Mb[3]);\nstatic void mldivide(const real_T A[9], const real_T B_2[3], real_T Y[3]);\nstatic real_T rtGetNaN(void);\nstatic real32_T rtGetNaNF(void);\n\n#define NOT_USING_NONFINITE_LITERALS   1\n\nextern real_T rtInf;\nextern real_T rtMinusInf;\nextern real_T rtNaN;\nextern real32_T rtInfF;\nextern real32_T rtMinusInfF;\nextern real32_T rtNaNF;\nstatic void rt_InitInfAndNaN(size_t realSize);\nstatic boolean_T rtIsInf(real_T value);\nstatic boolean_T rtIsInfF(real32_T value);\nstatic boolean_T rtIsNaN(real_T value);\nstatic boolean_T rtIsNaNF(real32_T value);\ntypedef struct {\n  struct {\n    uint32_T wordH;\n    uint32_T wordL;\n  } words;\n} BigEndianIEEEDouble;\n\ntypedef struct {\n  struct {\n    uint32_T wordL;\n    uint32_T wordH;\n  } words;\n} LittleEndianIEEEDouble;\n\ntypedef struct {\n  union {\n    real32_T wordLreal;\n    uint32_T wordLuint;\n  } wordL;\n} IEEESingle;\n\nreal_T rtInf;\nreal_T rtMinusInf;\nreal_T rtNaN;\nreal32_T rtInfF;\nreal32_T rtMinusInfF;\nreal32_T rtNaNF;\nstatic real_T rtGetInf(void);\nstatic real32_T rtGetInfF(void);\nstatic real_T rtGetMinusInf(void);\nstatic real32_T rtGetMinusInfF(void);\n\n/*\n * Initialize rtNaN needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nstatic real_T rtGetNaN(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T nan = 0.0;\n  if (bitsPerReal == 32U) {\n    nan = rtGetNaNF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0xFFF80000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    nan = tmpVal.fltVal;\n  }\n\n  return nan;\n}\n\n/*\n * Initialize rtNaNF needed by the generated code.\n * NaN is initialized as non-signaling. Assumes IEEE.\n */\nstatic real32_T rtGetNaNF(void)\n{\n  IEEESingle nanF = { { 0.0F } };\n\n  nanF.wordL.wordLuint = 0xFFC00000U;\n  return nanF.wordL.wordLreal;\n}\n\n/*\n * Initialize the rtInf, rtMinusInf, and rtNaN needed by the\n * generated code. NaN is initialized as non-signaling. Assumes IEEE.\n */\nstatic void rt_InitInfAndNaN(size_t realSize)\n{\n  (void) (realSize);\n  rtNaN = rtGetNaN();\n  rtNaNF = rtGetNaNF();\n  rtInf = rtGetInf();\n  rtInfF = rtGetInfF();\n  rtMinusInf = rtGetMinusInf();\n  rtMinusInfF = rtGetMinusInfF();\n}\n\n/* Test if value is infinite */\nstatic boolean_T rtIsInf(real_T value)\n{\n  return (boolean_T)((value==rtInf || value==rtMinusInf) ? 1U : 0U);\n}\n\n/* Test if single-precision value is infinite */\nstatic boolean_T rtIsInfF(real32_T value)\n{\n  return (boolean_T)(((value)==rtInfF || (value)==rtMinusInfF) ? 1U : 0U);\n}\n\n/* Test if value is not a number */\nstatic boolean_T rtIsNaN(real_T value)\n{\n  boolean_T result = (boolean_T) 0;\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  if (bitsPerReal == 32U) {\n    result = rtIsNaNF((real32_T)value);\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.fltVal = value;\n    result = (boolean_T)((tmpVal.bitVal.words.wordH & 0x7FF00000) == 0x7FF00000 &&\n                         ( (tmpVal.bitVal.words.wordH & 0x000FFFFF) != 0 ||\n                          (tmpVal.bitVal.words.wordL != 0) ));\n  }\n\n  return result;\n}\n\n/* Test if single-precision value is not a number */\nstatic boolean_T rtIsNaNF(real32_T value)\n{\n  IEEESingle tmp;\n  tmp.wordL.wordLreal = value;\n  return (boolean_T)( (tmp.wordL.wordLuint & 0x7F800000) == 0x7F800000 &&\n                     (tmp.wordL.wordLuint & 0x007FFFFF) != 0 );\n}\n\n/*\n * Initialize rtInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nstatic real_T rtGetInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T inf = 0.0;\n  if (bitsPerReal == 32U) {\n    inf = rtGetInfF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0x7FF00000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    inf = tmpVal.fltVal;\n  }\n\n  return inf;\n}\n\n/*\n * Initialize rtInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nstatic real32_T rtGetInfF(void)\n{\n  IEEESingle infF;\n  infF.wordL.wordLuint = 0x7F800000U;\n  return infF.wordL.wordLreal;\n}\n\n/*\n * Initialize rtMinusInf needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nstatic real_T rtGetMinusInf(void)\n{\n  size_t bitsPerReal = sizeof(real_T) * (NumBitsPerChar);\n  real_T minf = 0.0;\n  if (bitsPerReal == 32U) {\n    minf = rtGetMinusInfF();\n  } else {\n    union {\n      LittleEndianIEEEDouble bitVal;\n      real_T fltVal;\n    } tmpVal;\n\n    tmpVal.bitVal.words.wordH = 0xFFF00000U;\n    tmpVal.bitVal.words.wordL = 0x00000000U;\n    minf = tmpVal.fltVal;\n  }\n\n  return minf;\n}\n\n/*\n * Initialize rtMinusInfF needed by the generated code.\n * Inf is initialized as non-signaling. Assumes IEEE.\n */\nstatic real32_T rtGetMinusInfF(void)\n{\n  IEEESingle minfF;\n  minfF.wordL.wordLuint = 0xFF800000U;\n  return minfF.wordL.wordLreal;\n}\n\n/* Function for MATLAB Function: '<Root>/MATLAB Function' */\nstatic real_T norm(const real_T x[4])\n{\n  real_T absxk;\n  real_T scale;\n  real_T t;\n  real_T y;\n  scale = 3.3121686421112381E-170;\n  absxk = fabs(x[0]);\n  if (absxk > 3.3121686421112381E-170) {\n    y = 1.0;\n    scale = absxk;\n  } else {\n    t = absxk / 3.3121686421112381E-170;\n    y = t * t;\n  }\n\n  absxk = fabs(x[1]);\n  if (absxk > scale) {\n    t = scale / absxk;\n    y = y * t * t + 1.0;\n    scale = absxk;\n  } else {\n    t = absxk / scale;\n    y += t * t;\n  }\n\n  absxk = fabs(x[2]);\n  if (absxk > scale) {\n    t = scale / absxk;\n    y = y * t * t + 1.0;\n    scale = absxk;\n  } else {\n    t = absxk / scale;\n    y += t * t;\n  }\n\n  absxk = fabs(x[3]);\n  if (absxk > scale) {\n    t = scale / absxk;\n    y = y * t * t + 1.0;\n    scale = absxk;\n  } else {\n    t = absxk / scale;\n    y += t * t;\n  }\n\n  return scale * sqrt(y);\n}\n\n/* Function for MATLAB Function: '<Root>/MATLAB Function' */\nstatic real_T norm_j(const real_T x[3])\n{\n  real_T absxk;\n  real_T scale;\n  real_T t;\n  real_T y;\n  scale = 3.3121686421112381E-170;\n  absxk = fabs(x[0]);\n  if (absxk > 3.3121686421112381E-170) {\n    y = 1.0;\n    scale = absxk;\n  } else {\n    t = absxk / 3.3121686421112381E-170;\n    y = t * t;\n  }\n\n  absxk = fabs(x[1]);\n  if (absxk > scale) {\n    t = scale / absxk;\n    y = y * t * t + 1.0;\n    scale = absxk;\n  } else {\n    t = absxk / scale;\n    y += t * t;\n  }\n\n  absxk = fabs(x[2]);\n  if (absxk > scale) {\n    t = scale / absxk;\n    y = y * t * t + 1.0;\n    scale = absxk;\n  } else {\n    t = absxk / scale;\n    y += t * t;\n  }\n\n  return scale * sqrt(y);\n}\n\n/* Function for MATLAB Function: '<Root>/MATLAB Function' */\nstatic void aero(const real_T x[13], const real_T T[3], real_T del, const real_T\n                 w[3], const real_T b_drone_PHI[36], real_T b_drone_RHO, real_T\n                 b_drone_WET_SURFACE, real_T b_drone_DRY_SURFACE, real_T\n                 b_drone_PHI_n, real_T b_drone_CHORD, real_T b_drone_WINGSPAN,\n                 real_T b_drone_PROP_RADIUS, const real_T\n                 b_drone_ELEVON_MEFFICIENCY[3], const real_T\n                 b_drone_ELEVON_FEFFICIENCY[3], real_T Fb[3], real_T Mb[3])\n{\n  __m128d tmp;\n  __m128d tmp_0;\n  __m128d tmp_1;\n  real_T B_0[9];\n  real_T S[9];\n  real_T S_0[9];\n  real_T Sp[9];\n  real_T b_a[9];\n  real_T b_a_1[9];\n  real_T c_a[9];\n  real_T d_a_0[9];\n  real_T e_a[9];\n  real_T B_1[3];\n  real_T b_a_0[3];\n  real_T d_a[3];\n  real_T f_a[3];\n  real_T v[3];\n  real_T v_0[3];\n  real_T v_1[3];\n  real_T v_2[3];\n  real_T vinf[3];\n  real_T B_tmp;\n  real_T B_tmp_0;\n  real_T B_tmp_1;\n  real_T B_tmp_2;\n  real_T B_tmp_3;\n  real_T B_tmp_4;\n  real_T B_tmp_5;\n  real_T B_tmp_6;\n  real_T qin_idx_0;\n  real_T qin_idx_1;\n  real_T qin_idx_2;\n  real_T qin_idx_3;\n  int32_T b_a_tmp;\n  int32_T i;\n  int32_T i_0;\n  qin_idx_3 = norm(&x[6]);\n  qin_idx_0 = x[6] / qin_idx_3;\n  qin_idx_1 = x[7] / qin_idx_3;\n  qin_idx_2 = x[8] / qin_idx_3;\n  qin_idx_3 = x[9] / qin_idx_3;\n  B_tmp_1 = qin_idx_0 * qin_idx_0;\n  B_tmp_2 = qin_idx_1 * qin_idx_1;\n  B_tmp_3 = qin_idx_2 * qin_idx_2;\n  B_tmp_4 = qin_idx_3 * qin_idx_3;\n  B_0[0] = ((B_tmp_1 + B_tmp_2) - B_tmp_3) - B_tmp_4;\n  B_tmp = qin_idx_1 * qin_idx_2;\n  B_tmp_0 = qin_idx_0 * qin_idx_3;\n  B_0[3] = (B_tmp + B_tmp_0) * 2.0;\n  B_tmp_5 = qin_idx_1 * qin_idx_3;\n  B_tmp_6 = qin_idx_0 * qin_idx_2;\n  B_0[6] = (B_tmp_5 - B_tmp_6) * 2.0;\n  B_0[1] = (B_tmp - B_tmp_0) * 2.0;\n  B_tmp_1 -= B_tmp_2;\n  B_0[4] = (B_tmp_1 + B_tmp_3) - B_tmp_4;\n  B_tmp_2 = qin_idx_2 * qin_idx_3;\n  B_tmp = qin_idx_0 * qin_idx_1;\n  B_0[7] = (B_tmp_2 + B_tmp) * 2.0;\n  B_0[2] = (B_tmp_5 + B_tmp_6) * 2.0;\n  B_0[5] = (B_tmp_2 - B_tmp) * 2.0;\n  B_0[8] = (B_tmp_1 - B_tmp_3) + B_tmp_4;\n  qin_idx_3 = x[0] - w[0];\n  qin_idx_0 = x[1] - w[1];\n  qin_idx_1 = x[2] - w[2];\n  for (i = 0; i <= 0; i += 2) {\n    tmp = _mm_loadu_pd(&B_0[i]);\n    tmp_0 = _mm_loadu_pd(&B_0[i + 3]);\n    tmp_1 = _mm_loadu_pd(&B_0[i + 6]);\n    _mm_storeu_pd(&vinf[i], _mm_add_pd(_mm_mul_pd(tmp_1, _mm_set1_pd(qin_idx_1)),\n      _mm_add_pd(_mm_mul_pd(tmp_0, _mm_set1_pd(qin_idx_0)), _mm_add_pd\n                 (_mm_mul_pd(tmp, _mm_set1_pd(qin_idx_3)), _mm_set1_pd(0.0)))));\n  }\n\n  for (i = 2; i < 3; i++) {\n    vinf[i] = (B_0[i + 3] * qin_idx_0 + B_0[i] * qin_idx_3) + B_0[i + 6] *\n      qin_idx_1;\n  }\n\n  qin_idx_3 = b_drone_WET_SURFACE + b_drone_DRY_SURFACE;\n  memset(&B_0[0], 0, 9U * sizeof(real_T));\n  B_0[0] = b_drone_WINGSPAN;\n  B_0[4] = b_drone_CHORD;\n  B_0[8] = b_drone_WINGSPAN;\n  qin_idx_2 = norm_j(vinf);\n  qin_idx_0 = 0.5 * b_drone_WET_SURFACE / (b_drone_PROP_RADIUS *\n    b_drone_PROP_RADIUS * 3.1415926535897931);\n  for (i_0 = 0; i_0 <= 0; i_0 += 2) {\n    tmp = _mm_loadu_pd(&B_0[i_0]);\n    tmp_0 = _mm_loadu_pd(&B_0[i_0 + 3]);\n    tmp_1 = _mm_loadu_pd(&B_0[i_0 + 6]);\n    _mm_storeu_pd(&v[i_0], _mm_mul_pd(_mm_set1_pd(del), _mm_loadu_pd\n      (&b_drone_ELEVON_FEFFICIENCY[i_0])));\n    _mm_storeu_pd(&B_1[i_0], _mm_add_pd(_mm_mul_pd(tmp_1, _mm_set1_pd(x[5])),\n      _mm_add_pd(_mm_mul_pd(tmp_0, _mm_set1_pd(x[4])), _mm_add_pd(_mm_mul_pd(tmp,\n      _mm_set1_pd(x[3])), _mm_set1_pd(0.0)))));\n  }\n\n  for (i_0 = 2; i_0 < 3; i_0++) {\n    v[i_0] = del * b_drone_ELEVON_FEFFICIENCY[i_0];\n    B_1[i_0] = (B_0[i_0 + 3] * x[4] + B_0[i_0] * x[3]) + B_0[i_0 + 6] * x[5];\n  }\n\n  qin_idx_1 = norm_j(B_1);\n  qin_idx_2 = sqrt(qin_idx_1 * qin_idx_1 * b_drone_PHI_n + qin_idx_2 * qin_idx_2);\n  qin_idx_1 = -0.5 * b_drone_RHO * qin_idx_3 * qin_idx_2;\n  qin_idx_2 *= 0.5 * b_drone_RHO * qin_idx_3;\n  v_0[0] = v[1] * vinf[2] - vinf[1] * v[2];\n  v_0[1] = vinf[0] * v[2] - v[0] * vinf[2];\n  v_0[2] = v[0] * vinf[1] - vinf[0] * v[1];\n  v_1[0] = v[1] * x[5] - v[2] * x[4];\n  v_1[1] = v[2] * x[3] - v[0] * x[5];\n  v_1[2] = v[0] * x[4] - v[1] * x[3];\n  v_2[0] = v[1] * T[2] - T[1] * v[2];\n  v_2[1] = T[0] * v[2] - v[0] * T[2];\n  v_2[2] = v[0] * T[1] - T[0] * v[1];\n  for (i_0 = 0; i_0 < 3; i_0++) {\n    B_1[i_0] = 0.0;\n    b_a_0[i_0] = 0.0;\n    qin_idx_3 = 0.0;\n    d_a[i_0] = 0.0;\n    B_tmp_1 = 0.0;\n    f_a[i_0] = 0.0;\n    for (i = 0; i < 3; i++) {\n      b_a_tmp = 3 * i + i_0;\n      b_a[b_a_tmp] = 0.0;\n      B_tmp_2 = b_drone_PHI[i_0 + 3] * qin_idx_2 * B_0[3 * i];\n      b_a[b_a_tmp] += B_tmp_2;\n      B_tmp_3 = b_drone_PHI[i_0 + 9] * qin_idx_2 * B_0[3 * i + 1];\n      b_a[b_a_tmp] += B_tmp_3;\n      B_tmp_4 = b_drone_PHI[i_0 + 15] * qin_idx_2 * B_0[3 * i + 2];\n      b_a[b_a_tmp] += B_tmp_4;\n      B_tmp_6 = b_drone_PHI[6 * i + i_0];\n      B_tmp = B_tmp_6 * qin_idx_0;\n      qin_idx_3 += B_tmp * T[i];\n      e_a[b_a_tmp] = 0.0;\n      e_a[b_a_tmp] += B_tmp_2;\n      e_a[b_a_tmp] += B_tmp_3;\n      e_a[b_a_tmp] += B_tmp_4;\n      B_tmp_1 += e_a[b_a_tmp] * v_1[i];\n      B_1[i_0] += B_tmp_6 * qin_idx_1 * vinf[i];\n      b_a_0[i_0] += x[i + 3] * b_a[b_a_tmp];\n      d_a[i_0] += B_tmp_6 * qin_idx_2 * v_0[i];\n      f_a[i_0] += B_tmp * v_2[i];\n    }\n\n    Fb[i_0] = ((((B_1[i_0] - b_a_0[i_0]) - qin_idx_3) + d_a[i_0]) + B_tmp_1) +\n      f_a[i_0];\n    v[i_0] = del * b_drone_ELEVON_MEFFICIENCY[i_0];\n  }\n\n  v_0[0] = v[1] * vinf[2] - vinf[1] * v[2];\n  v_0[1] = vinf[0] * v[2] - v[0] * vinf[2];\n  v_0[2] = v[0] * vinf[1] - vinf[0] * v[1];\n  v_1[0] = v[1] * x[5] - v[2] * x[4];\n  v_1[1] = v[2] * x[3] - v[0] * x[5];\n  v_1[2] = v[0] * x[4] - v[1] * x[3];\n  v_2[0] = v[1] * T[2] - T[1] * v[2];\n  v_2[1] = T[0] * v[2] - v[0] * T[2];\n  v_2[2] = v[0] * T[1] - T[0] * v[1];\n  for (i = 0; i < 3; i++) {\n    int32_T n_a_tmp;\n    for (i_0 = 0; i_0 < 3; i_0++) {\n      n_a_tmp = 3 * i_0 + i;\n      e_a[n_a_tmp] = 0.0;\n      b_a[n_a_tmp] = 0.0;\n      B_tmp_1 = B_0[i];\n      e_a[n_a_tmp] += b_drone_PHI[6 * i_0 + 3] * (qin_idx_1 * B_tmp_1);\n      b_a_tmp = (i_0 + 3) * 6;\n      b_a[n_a_tmp] += b_drone_PHI[b_a_tmp + 3] * (qin_idx_2 * B_tmp_1);\n      B_tmp_1 = B_0[i + 3];\n      e_a[n_a_tmp] += b_drone_PHI[6 * i_0 + 4] * (qin_idx_1 * B_tmp_1);\n      b_a[n_a_tmp] += b_drone_PHI[b_a_tmp + 4] * (qin_idx_2 * B_tmp_1);\n      B_tmp_1 = B_0[i + 6];\n      e_a[n_a_tmp] += b_drone_PHI[6 * i_0 + 5] * (qin_idx_1 * B_tmp_1);\n      b_a[n_a_tmp] += b_drone_PHI[b_a_tmp + 5] * (qin_idx_2 * B_tmp_1);\n    }\n\n    B_1[i] = 0.0;\n    b_a_0[i] = 0.0;\n    qin_idx_3 = 0.0;\n    d_a[i] = 0.0;\n    for (i_0 = 0; i_0 < 3; i_0++) {\n      b_a_tmp = 3 * i_0 + i;\n      b_a_1[b_a_tmp] = 0.0;\n      b_a_1[b_a_tmp] += B_0[3 * i_0] * b_a[i];\n      b_a_1[b_a_tmp] += B_0[3 * i_0 + 1] * b_a[i + 3];\n      b_a_1[b_a_tmp] += B_0[3 * i_0 + 2] * b_a[i + 6];\n      c_a[b_a_tmp] = 0.0;\n      d_a_0[b_a_tmp] = 0.0;\n      B_tmp_1 = B_0[i];\n      B_tmp_2 = b_drone_PHI[6 * i_0 + 3];\n      c_a[b_a_tmp] += qin_idx_0 * B_tmp_1 * B_tmp_2;\n      d_a_0[b_a_tmp] += qin_idx_2 * B_tmp_1 * B_tmp_2;\n      B_tmp_1 = B_0[i + 3];\n      B_tmp_2 = b_drone_PHI[6 * i_0 + 4];\n      c_a[b_a_tmp] += qin_idx_0 * B_tmp_1 * B_tmp_2;\n      d_a_0[b_a_tmp] += qin_idx_2 * B_tmp_1 * B_tmp_2;\n      B_tmp_1 = B_0[i + 6];\n      B_tmp_2 = b_drone_PHI[6 * i_0 + 5];\n      c_a[b_a_tmp] += qin_idx_0 * B_tmp_1 * B_tmp_2;\n      d_a_0[b_a_tmp] += qin_idx_2 * B_tmp_1 * B_tmp_2;\n      qin_idx_3 += c_a[b_a_tmp] * T[i_0];\n      S[b_a_tmp] = 0.0;\n      n_a_tmp = (i_0 + 3) * 6;\n      S[b_a_tmp] += b_drone_PHI[n_a_tmp + 3] * (qin_idx_2 * B_0[i]);\n      S[b_a_tmp] += B_0[i + 3] * qin_idx_2 * b_drone_PHI[n_a_tmp + 4];\n      S[b_a_tmp] += B_0[i + 6] * qin_idx_2 * b_drone_PHI[n_a_tmp + 5];\n      B_1[i] += e_a[b_a_tmp] * vinf[i_0];\n      b_a_0[i] += x[i_0 + 3] * b_a_1[b_a_tmp];\n      d_a[i] += d_a_0[b_a_tmp] * v_0[i_0];\n    }\n\n    v[i] = (B_1[i] - b_a_0[i]) - qin_idx_3;\n    qin_idx_3 = 0.0;\n    f_a[i] = 0.0;\n    for (i_0 = 0; i_0 < 3; i_0++) {\n      n_a_tmp = 3 * i_0 + i;\n      S_0[n_a_tmp] = 0.0;\n      S_0[n_a_tmp] += B_0[3 * i_0] * S[i];\n      S_0[n_a_tmp] += B_0[3 * i_0 + 1] * S[i + 3];\n      S_0[n_a_tmp] += B_0[3 * i_0 + 2] * S[i + 6];\n      Sp[n_a_tmp] = 0.0;\n      Sp[n_a_tmp] += b_drone_PHI[6 * i_0 + 3] * (qin_idx_0 * B_0[i]);\n      Sp[n_a_tmp] += B_0[i + 3] * qin_idx_0 * b_drone_PHI[6 * i_0 + 4];\n      Sp[n_a_tmp] += B_0[i + 6] * qin_idx_0 * b_drone_PHI[6 * i_0 + 5];\n      qin_idx_3 += S_0[n_a_tmp] * v_1[i_0];\n      f_a[i] += Sp[n_a_tmp] * v_2[i_0];\n    }\n\n    Mb[i] = ((v[i] + d_a[i]) + qin_idx_3) + f_a[i];\n  }\n}\n\n/* Function for MATLAB Function: '<Root>/MATLAB Function' */\nstatic void mldivide(const real_T A[9], const real_T B_2[3], real_T Y[3])\n{\n  real_T b_A[9];\n  real_T a21;\n  real_T maxval;\n  int32_T r1;\n  int32_T r2;\n  int32_T r3;\n  memcpy(&b_A[0], &A[0], 9U * sizeof(real_T));\n  r1 = 0;\n  r2 = 1;\n  r3 = 2;\n  maxval = fabs(A[0]);\n  a21 = fabs(A[1]);\n  if (a21 > maxval) {\n    maxval = a21;\n    r1 = 1;\n    r2 = 0;\n  }\n\n  if (fabs(A[2]) > maxval) {\n    r1 = 2;\n    r2 = 1;\n    r3 = 0;\n  }\n\n  b_A[r2] = A[r2] / A[r1];\n  b_A[r3] /= b_A[r1];\n  b_A[r2 + 3] -= b_A[r1 + 3] * b_A[r2];\n  b_A[r3 + 3] -= b_A[r1 + 3] * b_A[r3];\n  b_A[r2 + 6] -= b_A[r1 + 6] * b_A[r2];\n  b_A[r3 + 6] -= b_A[r1 + 6] * b_A[r3];\n  if (fabs(b_A[r3 + 3]) > fabs(b_A[r2 + 3])) {\n    int32_T rtemp;\n    rtemp = r2;\n    r2 = r3;\n    r3 = rtemp;\n  }\n\n  b_A[r3 + 3] /= b_A[r2 + 3];\n  b_A[r3 + 6] -= b_A[r3 + 3] * b_A[r2 + 6];\n  Y[1] = B_2[r2] - B_2[r1] * b_A[r2];\n  Y[2] = (B_2[r3] - B_2[r1] * b_A[r3]) - b_A[r3 + 3] * Y[1];\n  Y[2] /= b_A[r3 + 6];\n  Y[0] = B_2[r1] - b_A[r1 + 6] * Y[2];\n  Y[1] -= b_A[r2 + 6] * Y[2];\n  Y[1] /= b_A[r2 + 3];\n  Y[0] -= b_A[r1 + 3] * Y[1];\n  Y[0] /= b_A[r1];\n}\n\n/* Model step function */\nvoid darko_step(void)\n{\n  real_T b[9];\n  real_T A1[3];\n  real_T A2[3];\n  real_T M1[3];\n  real_T M2[3];\n  real_T T1[3];\n  real_T T2[3];\n  real_T b_b[3];\n  real_T b_tmp[3];\n  static const real_T e[9] = { 0.007018, 0.0, 0.0, 0.0, 0.002785, 0.0, 0.0, 0.0,\n    0.00606 };\n\n  real_T rtb_dxdt[13];\n  real_T M1_0[3];\n  real_T b_b_0[3];\n  real_T b_tmp_0;\n  real_T b_tmp_1;\n  real_T b_tmp_2;\n  real_T b_tmp_3;\n  real_T b_tmp_4;\n  real_T b_tmp_5;\n  real_T b_tmp_6;\n  real_T b_tmp_7;\n  real_T qin_idx_0;\n  real_T qin_idx_1;\n  real_T qin_idx_2;\n  real_T qin_idx_3;\n  real_T rtb_u_idx_0;\n  real_T rtb_u_idx_1;\n  int32_T i;\n  int8_T T1_tmp[3];\n  static const real_T d_PHI[36] = { 0.025, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.1,\n    0.0, 0.0, 0.0, -0.0023636363636363642, 0.0, 0.0, 3.938822097203273, 0.0,\n    0.39388220972032734, 0.0, 0.0, 0.0, 0.0, 0.1396, 0.0, 0.0405, 0.0, 0.0,\n    -0.0023636363636363642, 0.0, 0.63575, 0.0, 0.0, 0.39388220972032734, 0.0,\n    0.05725, 0.0, 0.00195 };\n\n  static const real_T d_ELEVON_MEFFICIENCY[3] = { 0.0, 0.93, 0.0 };\n\n  static const real_T d_ELEVON_FEFFICIENCY[3] = { 0.0, 0.48, 0.0 };\n\n  static const real_T e_0[9] = { 0.007018, 0.0, 0.0, 0.0, 0.002785, 0.0, 0.0,\n    0.0, 0.00606 };\n\n  static const real_T f[9] = { -0.007018, -0.0, -0.0, -0.0, -0.002785, -0.0,\n    -0.0, -0.0, -0.00606 };\n\n  static const real_T g[3] = { 0.0, 0.0, 9.81 };\n\n  /* Outport: '<Root>/p' incorporates:\n   *  DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\n   */\n  rtY.p[0] = rtDW.DiscreteTimeIntegrator_DSTATE[0];\n\n  /* Outport: '<Root>/v' incorporates:\n   *  DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\n   */\n  rtY.v[0] = rtDW.DiscreteTimeIntegrator_DSTATE[3];\n\n  /* Outport: '<Root>/p' incorporates:\n   *  DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\n   */\n  rtY.p[1] = rtDW.DiscreteTimeIntegrator_DSTATE[1];\n\n  /* Outport: '<Root>/v' incorporates:\n   *  DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\n   */\n  rtY.v[1] = rtDW.DiscreteTimeIntegrator_DSTATE[4];\n\n  /* Outport: '<Root>/p' incorporates:\n   *  DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\n   */\n  rtY.p[2] = rtDW.DiscreteTimeIntegrator_DSTATE[2];\n\n  /* Outport: '<Root>/v' incorporates:\n   *  DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\n   */\n  rtY.v[2] = rtDW.DiscreteTimeIntegrator_DSTATE[5];\n\n  /* Outport: '<Root>/q' incorporates:\n   *  DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\n   */\n  rtY.q[0] = rtDW.DiscreteTimeIntegrator_DSTATE[6];\n  rtY.q[1] = rtDW.DiscreteTimeIntegrator_DSTATE[7];\n  rtY.q[2] = rtDW.DiscreteTimeIntegrator_DSTATE[8];\n  rtY.q[3] = rtDW.DiscreteTimeIntegrator_DSTATE[9];\n\n  /* Outport: '<Root>/omega' incorporates:\n   *  DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\n   */\n  rtY.omega[0] = rtDW.DiscreteTimeIntegrator_DSTATE[10];\n  rtY.omega[1] = rtDW.DiscreteTimeIntegrator_DSTATE[11];\n  rtY.omega[2] = rtDW.DiscreteTimeIntegrator_DSTATE[12];\n\n  /* MATLAB Function: '<Root>/MATLAB Function1' incorporates:\n   *  Inport: '<Root>/u'\n   */\n  rtb_u_idx_0 = -rtU.u[0] * 1000.0;\n  rtb_u_idx_1 = rtU.u[1] * 1000.0;\n\n  /* MATLAB Function: '<Root>/MATLAB Function' incorporates:\n   *  DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\n   *  Inport: '<Root>/u'\n   *  Inport: '<Root>/w'\n   *  MATLAB Function: '<Root>/MATLAB Function1'\n   */\n  b_tmp_2 = norm(&rtDW.DiscreteTimeIntegrator_DSTATE[6]);\n  qin_idx_0 = rtDW.DiscreteTimeIntegrator_DSTATE[6] / b_tmp_2;\n  qin_idx_1 = rtDW.DiscreteTimeIntegrator_DSTATE[7] / b_tmp_2;\n  qin_idx_2 = rtDW.DiscreteTimeIntegrator_DSTATE[8] / b_tmp_2;\n  qin_idx_3 = rtDW.DiscreteTimeIntegrator_DSTATE[9] / b_tmp_2;\n  b_tmp_2 = qin_idx_0 * qin_idx_0;\n  b_tmp_3 = qin_idx_1 * qin_idx_1;\n  b_tmp_4 = qin_idx_2 * qin_idx_2;\n  b_tmp_5 = qin_idx_3 * qin_idx_3;\n  b[0] = ((b_tmp_2 + b_tmp_3) - b_tmp_4) - b_tmp_5;\n  b_tmp_0 = qin_idx_1 * qin_idx_2;\n  b_tmp_1 = qin_idx_0 * qin_idx_3;\n  b[3] = (b_tmp_0 + b_tmp_1) * 2.0;\n  b_tmp_6 = qin_idx_1 * qin_idx_3;\n  b_tmp_7 = qin_idx_0 * qin_idx_2;\n  b[6] = (b_tmp_6 - b_tmp_7) * 2.0;\n  b[1] = (b_tmp_0 - b_tmp_1) * 2.0;\n  b_tmp_2 -= b_tmp_3;\n  b[4] = (b_tmp_2 + b_tmp_4) - b_tmp_5;\n  b_tmp_3 = qin_idx_2 * qin_idx_3;\n  b_tmp_0 = qin_idx_0 * qin_idx_1;\n  b[7] = (b_tmp_3 + b_tmp_0) * 2.0;\n  b[2] = (b_tmp_6 + b_tmp_7) * 2.0;\n  b[5] = (b_tmp_3 - b_tmp_0) * 2.0;\n  b[8] = (b_tmp_2 - b_tmp_4) + b_tmp_5;\n  qin_idx_2 = rtb_u_idx_0 * rtb_u_idx_0;\n  qin_idx_0 = qin_idx_2 * 5.13E-6;\n  qin_idx_3 = rtb_u_idx_1 * rtb_u_idx_1;\n  qin_idx_1 = qin_idx_3 * 5.13E-6;\n  T1[0] = qin_idx_0;\n  T2[0] = qin_idx_1;\n  T1_tmp[0] = 1;\n  T1[1] = qin_idx_0 * 0.0;\n  T2[1] = qin_idx_1 * 0.0;\n  T1_tmp[1] = 0;\n  T1[2] = qin_idx_0 * 0.0;\n  T2[2] = qin_idx_1 * 0.0;\n  T1_tmp[2] = 0;\n  if (rtIsNaN(-rtb_u_idx_0)) {\n    b_tmp_2 = (rtNaN);\n  } else if (-rtb_u_idx_0 < 0.0) {\n    b_tmp_2 = -1.0;\n  } else {\n    b_tmp_2 = (-rtb_u_idx_0 > 0.0);\n  }\n\n  qin_idx_0 = b_tmp_2 * 2.64E-7 * qin_idx_2;\n  if (rtIsNaN(-rtb_u_idx_1)) {\n    b_tmp_2 = (rtNaN);\n  } else if (-rtb_u_idx_1 < 0.0) {\n    b_tmp_2 = -1.0;\n  } else {\n    b_tmp_2 = (-rtb_u_idx_1 > 0.0);\n  }\n\n  qin_idx_1 = b_tmp_2 * 2.64E-7 * qin_idx_3;\n  aero(rtDW.DiscreteTimeIntegrator_DSTATE, T1, rtU.u[2] * 30.0 *\n       0.017453292519943295, rtU.w, d_PHI, 1.225, 0.0743, 0.0, 0.0, 0.13, 0.55,\n       0.125, d_ELEVON_MEFFICIENCY, d_ELEVON_FEFFICIENCY, A1, M1);\n  aero(rtDW.DiscreteTimeIntegrator_DSTATE, T2, rtU.u[3] * 30.0 *\n       0.017453292519943295, rtU.w, d_PHI, 1.225, 0.0743, 0.0, 0.0, 0.13, 0.55,\n       0.125, d_ELEVON_MEFFICIENCY, d_ELEVON_FEFFICIENCY, A2, M2);\n  rtb_u_idx_0 = (rtb_u_idx_0 + rtDW.DiscreteTimeIntegrator_DSTATE[10]) *\n    5.1116E-6;\n  b_tmp[0] = 0.0;\n  b_tmp[1] = rtDW.DiscreteTimeIntegrator_DSTATE[12];\n  b_tmp[2] = -rtDW.DiscreteTimeIntegrator_DSTATE[11];\n  rtb_u_idx_1 = (rtb_u_idx_1 + rtDW.DiscreteTimeIntegrator_DSTATE[10]) *\n    5.1116E-6;\n  for (i = 0; i <= 0; i += 2) {\n    /* MATLAB Function: '<Root>/MATLAB Function' incorporates:\n     *  DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\n     */\n    _mm_storeu_pd(&b_b[i], _mm_add_pd(_mm_mul_pd(_mm_loadu_pd(&e[i + 6]),\n      _mm_set1_pd(rtDW.DiscreteTimeIntegrator_DSTATE[12])), _mm_add_pd\n      (_mm_mul_pd(_mm_loadu_pd(&e[i + 3]), _mm_set1_pd\n                  (rtDW.DiscreteTimeIntegrator_DSTATE[11])), _mm_add_pd\n       (_mm_mul_pd(_mm_loadu_pd(&e[i]), _mm_set1_pd\n                   (rtDW.DiscreteTimeIntegrator_DSTATE[10])), _mm_set1_pd(0.0)))));\n  }\n\n  /* MATLAB Function: '<Root>/MATLAB Function' incorporates:\n   *  DiscreteIntegrator: '<Root>/Discrete-Time Integrator'\n   */\n  for (i = 2; i < 3; i++) {\n    b_b[i] = (e_0[i + 3] * rtDW.DiscreteTimeIntegrator_DSTATE[11] + e_0[i] *\n              rtDW.DiscreteTimeIntegrator_DSTATE[10]) + e_0[i + 6] *\n      rtDW.DiscreteTimeIntegrator_DSTATE[12];\n  }\n\n  qin_idx_2 = ((T1[0] + T2[0]) + A1[0]) + A2[0];\n  qin_idx_3 = ((T1[1] + T2[1]) + A1[1]) + A2[1];\n  b_tmp_3 = ((T1[2] + T2[2]) + A1[2]) + A2[2];\n  b_b_0[0] = b_b[2] * rtDW.DiscreteTimeIntegrator_DSTATE[11] - b_b[1] *\n    rtDW.DiscreteTimeIntegrator_DSTATE[12];\n  b_b_0[1] = b_b[0] * rtDW.DiscreteTimeIntegrator_DSTATE[12] - b_b[2] *\n    rtDW.DiscreteTimeIntegrator_DSTATE[10];\n  b_b_0[2] = b_b[1] * rtDW.DiscreteTimeIntegrator_DSTATE[10] - b_b[0] *\n    rtDW.DiscreteTimeIntegrator_DSTATE[11];\n  mldivide(f, b_b_0, b_b);\n  b_b_0[0] = -0.155 * A1[2] - 0.0 * A1[1];\n  b_b_0[1] = 0.0 * A1[0] - 0.0 * A1[2];\n  b_b_0[2] = 0.0 * A1[1] - -0.155 * A1[0];\n  A1[0] = 0.155 * A2[2] - 0.0 * A2[1];\n  A1[1] = 0.0 * A2[0] - 0.0 * A2[2];\n  A1[2] = 0.0 * A2[1] - 0.155 * A2[0];\n  A2[0] = -0.155 * T1[2] - 0.0 * T1[1];\n  A2[1] = 0.0 * T1[0] - 0.065 * T1[2];\n  A2[2] = 0.065 * T1[1] - -0.155 * T1[0];\n  T1[0] = 0.155 * T2[2] - 0.0 * T2[1];\n  T1[1] = 0.0 * T2[0] - 0.065 * T2[2];\n  T1[2] = 0.065 * T2[1] - 0.155 * T2[0];\n  for (i = 0; i < 3; i++) {\n    int32_T T1_tmp_0;\n    b_tmp_2 = b_tmp[i];\n    T1_tmp_0 = T1_tmp[i];\n    T2[i] = ((b[3 * i + 1] * 2.0325203252032522 * qin_idx_3 + b[3 * i] *\n              2.0325203252032522 * qin_idx_2) + b[3 * i + 2] *\n             2.0325203252032522 * b_tmp_3) + g[i];\n    M1_0[i] = ((((qin_idx_0 * (real_T)T1_tmp_0 - rtb_u_idx_0 * b_tmp_2) +\n                 (qin_idx_1 * (real_T)T1_tmp_0 - rtb_u_idx_1 * b_tmp_2)) + A2[i])\n               + T1[i]) + (((M1[i] + M2[i]) + b_b_0[i]) + A1[i]);\n  }\n\n  mldivide(e_0, M1_0, b_b_0);\n  rtb_dxdt[0] = rtDW.DiscreteTimeIntegrator_DSTATE[3];\n  rtb_dxdt[3] = T2[0];\n  rtb_dxdt[1] = rtDW.DiscreteTimeIntegrator_DSTATE[4];\n  rtb_dxdt[4] = T2[1];\n  rtb_dxdt[2] = rtDW.DiscreteTimeIntegrator_DSTATE[5];\n  rtb_dxdt[5] = T2[2];\n  rtb_dxdt[6] = ((rtDW.DiscreteTimeIntegrator_DSTATE[7] *\n                  rtDW.DiscreteTimeIntegrator_DSTATE[10] +\n                  rtDW.DiscreteTimeIntegrator_DSTATE[8] *\n                  rtDW.DiscreteTimeIntegrator_DSTATE[11]) +\n                 rtDW.DiscreteTimeIntegrator_DSTATE[9] *\n                 rtDW.DiscreteTimeIntegrator_DSTATE[12]) * -0.5;\n  rtb_dxdt[7] = (rtDW.DiscreteTimeIntegrator_DSTATE[6] *\n                 rtDW.DiscreteTimeIntegrator_DSTATE[10] -\n                 (rtDW.DiscreteTimeIntegrator_DSTATE[9] *\n                  rtDW.DiscreteTimeIntegrator_DSTATE[11] -\n                  rtDW.DiscreteTimeIntegrator_DSTATE[8] *\n                  rtDW.DiscreteTimeIntegrator_DSTATE[12])) * 0.5;\n  rtb_dxdt[8] = (rtDW.DiscreteTimeIntegrator_DSTATE[6] *\n                 rtDW.DiscreteTimeIntegrator_DSTATE[11] -\n                 (rtDW.DiscreteTimeIntegrator_DSTATE[7] *\n                  rtDW.DiscreteTimeIntegrator_DSTATE[12] -\n                  rtDW.DiscreteTimeIntegrator_DSTATE[9] *\n                  rtDW.DiscreteTimeIntegrator_DSTATE[10])) * 0.5;\n  rtb_dxdt[9] = (rtDW.DiscreteTimeIntegrator_DSTATE[6] *\n                 rtDW.DiscreteTimeIntegrator_DSTATE[12] -\n                 (rtDW.DiscreteTimeIntegrator_DSTATE[8] *\n                  rtDW.DiscreteTimeIntegrator_DSTATE[10] -\n                  rtDW.DiscreteTimeIntegrator_DSTATE[7] *\n                  rtDW.DiscreteTimeIntegrator_DSTATE[11])) * 0.5;\n  rtb_dxdt[10] = b_b[0] + b_b_0[0];\n\n  /* Outport: '<Root>/accel' incorporates:\n   *  MATLAB Function: '<Root>/MATLAB Function'\n   */\n  rtY.accel[0] = T2[0];\n\n  /* Outport: '<Root>/rotaccel' */\n  rtY.rotaccel[0] = rtb_dxdt[10];\n\n  /* MATLAB Function: '<Root>/MATLAB Function' */\n  rtb_dxdt[11] = b_b[1] + b_b_0[1];\n\n  /* Outport: '<Root>/accel' incorporates:\n   *  MATLAB Function: '<Root>/MATLAB Function'\n   */\n  rtY.accel[1] = T2[1];\n\n  /* Outport: '<Root>/rotaccel' */\n  rtY.rotaccel[1] = rtb_dxdt[11];\n\n  /* MATLAB Function: '<Root>/MATLAB Function' */\n  rtb_dxdt[12] = b_b[2] + b_b_0[2];\n\n  /* Outport: '<Root>/accel' incorporates:\n   *  MATLAB Function: '<Root>/MATLAB Function'\n   */\n  rtY.accel[2] = T2[2];\n\n  /* Outport: '<Root>/rotaccel' */\n  rtY.rotaccel[2] = rtb_dxdt[12];\n  for (i = 0; i <= 10; i += 2) {\n    __m128d tmp;\n    __m128d tmp_0;\n\n    /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator' */\n    tmp = _mm_loadu_pd(&rtb_dxdt[i]);\n    tmp_0 = _mm_loadu_pd(&rtDW.DiscreteTimeIntegrator_DSTATE[i]);\n    _mm_storeu_pd(&rtDW.DiscreteTimeIntegrator_DSTATE[i], _mm_add_pd(_mm_mul_pd\n      (_mm_set1_pd(0.000977), tmp), tmp_0));\n  }\n\n  /* Update for DiscreteIntegrator: '<Root>/Discrete-Time Integrator' */\n  for (i = 12; i < 13; i++) {\n    rtDW.DiscreteTimeIntegrator_DSTATE[i] += 0.000977 * rtb_dxdt[i];\n  }\n}\n\n/* Model initialize function */\nvoid darko_initialize(void)\n{\n  /* Registration code */\n\n  /* initialize non-finites */\n  rt_InitInfAndNaN(sizeof(real_T));\n\n  /* InitializeConditions for DiscreteIntegrator: '<Root>/Discrete-Time Integrator' */\n  memcpy(&rtDW.DiscreteTimeIntegrator_DSTATE[0],\n         &rtConstP.DiscreteTimeIntegrator_IC[0], 13U * sizeof(real_T));\n}\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"darko.h","type":"header","group":"model","path":"/home/florian/MATLAB-Drive/test_Embedded Coder/Darko/darko_ert_rtw","tag":"","groupDisplay":"Model files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: darko.h\n *\n * Code generated for Simulink model 'darko'.\n *\n * Model version                  : 1.10\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\n * C/C++ source code generated on : Mon Dec 12 08:31:49 2022\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives:\n *    1. Execution efficiency\n *    2. RAM efficiency\n * Validation result: Not run\n */\n\n#ifndef RTW_HEADER_darko_h_\n#define RTW_HEADER_darko_h_\n#ifndef darko_COMMON_INCLUDES_\n#define darko_COMMON_INCLUDES_\n#include \"rtwtypes.h\"\n#endif                                 /* darko_COMMON_INCLUDES_ */\n\n/* Macros for accessing real-time model data structure */\n#ifndef rtmGetErrorStatus\n#define rtmGetErrorStatus(rtm)         ((rtm)->errorStatus)\n#endif\n\n#ifndef rtmSetErrorStatus\n#define rtmSetErrorStatus(rtm, val)    ((rtm)->errorStatus = (val))\n#endif\n\n/* Forward declaration for rtModel */\ntypedef struct tag_RTM RT_MODEL;\n\n#ifndef DEFINED_TYPEDEF_FOR_struct_YysP9KtKw43hFSdxSlefvD_\n#define DEFINED_TYPEDEF_FOR_struct_YysP9KtKw43hFSdxSlefvD_\n\ntypedef struct {\n  real_T MASS;\n  real_T INERTIA[9];\n  real_T G;\n  real_T P_P1_CG[3];\n  real_T P_P2_CG[3];\n  real_T P_A1_CG[3];\n  real_T P_A2_CG[3];\n  real_T INERTIA_PROP_X;\n  real_T INERTIA_PROP_N;\n  real_T PHI[36];\n  real_T RHO;\n  real_T WET_SURFACE;\n  real_T DRY_SURFACE;\n  real_T PHI_n;\n  real_T CHORD;\n  real_T WINGSPAN;\n  real_T PROP_RADIUS;\n  real_T ELEVON_MEFFICIENCY[3];\n  real_T ELEVON_FEFFICIENCY[3];\n  real_T PROP_KP;\n  real_T THICKNESS;\n  real_T PROP_KM;\n} struct_YysP9KtKw43hFSdxSlefvD;\n\n#endif\n\n/* Block signals and states (default storage) for system '<Root>' */\ntypedef struct {\n  real_T DiscreteTimeIntegrator_DSTATE[13];/* '<Root>/Discrete-Time Integrator' */\n} DW;\n\n/* Constant parameters (default storage) */\ntypedef struct {\n  /* Expression: initial_state\n   * Referenced by: '<Root>/Discrete-Time Integrator'\n   */\n  real_T DiscreteTimeIntegrator_IC[13];\n} ConstP;\n\n/* External inputs (root inport signals with default storage) */\ntypedef struct {\n  real_T u[4];                         /* '<Root>/u' */\n  real_T w[3];                         /* '<Root>/w' */\n} ExtU;\n\n/* External outputs (root outports fed by signals with default storage) */\ntypedef struct {\n  real_T p[3];                         /* '<Root>/p' */\n  real_T v[3];                         /* '<Root>/v' */\n  real_T q[4];                         /* '<Root>/q' */\n  real_T omega[3];                     /* '<Root>/omega' */\n  real_T accel[3];                     /* '<Root>/accel' */\n  real_T rotaccel[3];                  /* '<Root>/rotaccel' */\n} ExtY;\n\n/* Real-time Model Data Structure */\nstruct tag_RTM {\n  const char_T * volatile errorStatus;\n};\n\n/* Block signals and states (default storage) */\nextern DW rtDW;\n\n/* External inputs (root inport signals with default storage) */\nextern ExtU rtU;\n\n/* External outputs (root outports fed by signals with default storage) */\nextern ExtY rtY;\n\n/* Constant parameters (default storage) */\nextern const ConstP rtConstP;\n\n/* Model entry point functions */\nextern void darko_initialize(void);\nextern void darko_step(void);\n\n/* Real-time Model object */\nextern RT_MODEL *const rtM;\n\n/*-\n * The generated code includes comments that allow you to trace directly\n * back to the appropriate location in the model.  The basic format\n * is <system>/block_name, where system is the system number (uniquely\n * assigned by Simulink) and block_name is the name of the block.\n *\n * Use the MATLAB hilite_system command to trace the generated code back\n * to the model.  For example,\n *\n * hilite_system('<S3>')    - opens system 3\n * hilite_system('<S3>/Kp') - opens and selects block Kp which resides in S3\n *\n * Here is the system hierarchy for this model\n *\n * '<Root>' : 'darko'\n * '<S1>'   : 'darko/MATLAB Function'\n * '<S2>'   : 'darko/MATLAB Function1'\n */\n#endif                                 /* RTW_HEADER_darko_h_ */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"darko_data.c","type":"source","group":"data","path":"/home/florian/MATLAB-Drive/test_Embedded Coder/Darko/darko_ert_rtw","tag":"","groupDisplay":"Data files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: darko_data.c\n *\n * Code generated for Simulink model 'darko'.\n *\n * Model version                  : 1.10\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\n * C/C++ source code generated on : Mon Dec 12 08:31:49 2022\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives:\n *    1. Execution efficiency\n *    2. RAM efficiency\n * Validation result: Not run\n */\n\n#include \"darko.h\"\n\n/* Constant parameters (default storage) */\nconst ConstP rtConstP = {\n  /* Expression: initial_state\n   * Referenced by: '<Root>/Discrete-Time Integrator'\n   */\n  { 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.70710678118654757, 0.0, 0.70710678118654746,\n    0.0, 0.0, 0.0, 0.0 }\n};\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"},{"name":"rtwtypes.h","type":"header","group":"utility","path":"/home/florian/MATLAB-Drive/test_Embedded Coder/Darko/darko_ert_rtw","tag":"","groupDisplay":"Utility files","code":"/*\n * Academic License - for use in teaching, academic research, and meeting\n * course requirements at degree granting institutions only.  Not for\n * government, commercial, or other organizational use.\n *\n * File: rtwtypes.h\n *\n * Code generated for Simulink model 'darko'.\n *\n * Model version                  : 1.10\n * Simulink Coder version         : 9.8 (R2022b) 13-May-2022\n * C/C++ source code generated on : Mon Dec 12 08:31:49 2022\n *\n * Target selection: ert.tlc\n * Embedded hardware selection: Intel->x86-64 (Linux 64)\n * Code generation objectives:\n *    1. Execution efficiency\n *    2. RAM efficiency\n * Validation result: Not run\n */\n\n#ifndef RTWTYPES_H\n#define RTWTYPES_H\n\n/* Logical type definitions */\n#if (!defined(__cplusplus))\n#ifndef false\n#define false                          (0U)\n#endif\n\n#ifndef true\n#define true                           (1U)\n#endif\n#endif\n\n/*=======================================================================*\n * Target hardware information\n *   Device type: Intel->x86-64 (Linux 64)\n *   Number of bits:     char:   8    short:   16    int:  32\n *                       long:  64    long long:  64\n *                       native word size:  64\n *   Byte ordering: LittleEndian\n *   Signed integer division rounds to: Zero\n *   Shift right on a signed integer as arithmetic shift: on\n *=======================================================================*/\n\n/*=======================================================================*\n * Fixed width word size data types:                                     *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *   real32_T, real64_T           - 32 and 64 bit floating point numbers *\n *=======================================================================*/\ntypedef signed char int8_T;\ntypedef unsigned char uint8_T;\ntypedef short int16_T;\ntypedef unsigned short uint16_T;\ntypedef int int32_T;\ntypedef unsigned int uint32_T;\ntypedef long int64_T;\ntypedef unsigned long uint64_T;\ntypedef float real32_T;\ntypedef double real64_T;\n\n/*===========================================================================*\n * Generic type definitions: boolean_T, char_T, byte_T, int_T, uint_T,       *\n *                           real_T, time_T, ulong_T, ulonglong_T.           *\n *===========================================================================*/\ntypedef double real_T;\ntypedef double time_T;\ntypedef unsigned char boolean_T;\ntypedef int int_T;\ntypedef unsigned int uint_T;\ntypedef unsigned long ulong_T;\ntypedef unsigned long long ulonglong_T;\ntypedef char char_T;\ntypedef unsigned char uchar_T;\ntypedef char_T byte_T;\n\n/*=======================================================================*\n * Min and Max:                                                          *\n *   int8_T, int16_T, int32_T     - signed 8, 16, or 32 bit integers     *\n *   uint8_T, uint16_T, uint32_T  - unsigned 8, 16, or 32 bit integers   *\n *=======================================================================*/\n#define MAX_int8_T                     ((int8_T)(127))\n#define MIN_int8_T                     ((int8_T)(-128))\n#define MAX_uint8_T                    ((uint8_T)(255U))\n#define MAX_int16_T                    ((int16_T)(32767))\n#define MIN_int16_T                    ((int16_T)(-32768))\n#define MAX_uint16_T                   ((uint16_T)(65535U))\n#define MAX_int32_T                    ((int32_T)(2147483647))\n#define MIN_int32_T                    ((int32_T)(-2147483647-1))\n#define MAX_uint32_T                   ((uint32_T)(0xFFFFFFFFU))\n#define MAX_int64_T                    ((int64_T)(9223372036854775807L))\n#define MIN_int64_T                    ((int64_T)(-9223372036854775807L-1L))\n#define MAX_uint64_T                   ((uint64_T)(0xFFFFFFFFFFFFFFFFUL))\n\n/* Block D-Work pointer type */\ntypedef void * pointer_T;\n\n#endif                                 /* RTWTYPES_H */\n\n/*\n * File trailer for generated code.\n *\n * [EOF]\n */\n"}],"features":{"annotation":false,"coverage":true,"profiling":true,"tooltip":true,"coverageTooltip":false,"showJustificationLinks":false,"showProfilingInfo":false,"showTaskSummary":false}};